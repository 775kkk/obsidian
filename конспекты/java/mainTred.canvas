{
	"nodes":[
		{"id":"4b1a847774f985d2","type":"text","text":"# switch\nЕсли в `case` отсутствует ключевое слово `break`, то будут выполнены и следующие `case` , включая `default` case. Случай `default` также выполняется, если нет другого `case` , соответствующего значению переменной. Ключевое слово `break` в ветви `default` является необязательным и может быть опущено.\n\nРаздел `case` может содержать любой блок кода, даже вложенный раздел `switch`, однако по возможности рекомендуется избегать глубоко вложенных структур кода.","x":2080,"y":-1960,"width":770,"height":260},
		{"id":"f2d9c1a3f95149ef","type":"text","text":"# ЗАМЕТКИ ПО КОДУ","x":2308,"y":-2110,"width":315,"height":70},
		{"id":"8e5746be3065a747","type":"text","text":"# `public static void main(String[] args)`\n- ключевое слово `public` указывает на то, что метод можно вызывать откуда угодно;\n- ключевое слово `static` указывает на то, что метод можно вызвать без создания экземпляра класса;\n- ключевое слово `void` указывает на то, что метод не возвращает никакого значения;\n- переменная массива `args` содержит аргументы, введенные в командной строке. Если аргументов нет, массив будет пустым.\nесли есть слово `static`, то метод **статический**; если слова `static` нет, то метод **экземплярный**.","x":-2800,"y":-3440,"width":579,"height":380},
		{"id":"56d57a9d46479ede","type":"text","text":"> Exception in thread \"main\" java.lang.NumberFormatException: For input string: \"121a\"\n>   at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n>   at java.base/java.lang.Integer.parseInt(Integer.java:652)\n>   at java.base/java.lang.Integer.parseInt(Integer.java:770)\n>   at NumberFormatExceptionDemo.main(NumberFormatExceptionDemo.java:9)\n  \nВ этом сообщении отображается тип исключения (`NumberFormatException`) и переданная входная строка. Место, где возникло исключение, указано в последней строке сообщения:\n- имя файла - `NumberFormatExceptionDemo.java`;\n- `main` способ;\n- строка 9.\nВо всех предыдущих строках сообщения указаны позиции внутри метода `parseInt`, который является частью стандартной библиотеки.","x":-2837,"y":-3003,"width":960,"height":377},
		{"id":"160202c8eab874dd","type":"text","text":"Если вы хотите поместить в один `.java` файл несколько классов. ТО только один из всех можно объявить как `public` , а имя `.java` файла должно совпадать с именеv `public`-класса в файле.","x":-2800,"y":-2580,"width":381,"height":184},
		{"id":"ccfba42f4ab31dfb","type":"file","file":"конспекты/java/3.svg","x":-2818,"y":-2360,"width":923,"height":233},
		{"id":"66b0b0a9513ab9f5","type":"file","file":"конспекты/java/1.svg","x":-2800,"y":-2075,"width":799,"height":544,"color":"6"},
		{"id":"e0a45146fe80d6a3","type":"text","text":"# Методы экземпляра: особенности\nУ методов экземпляра есть большое преимущество: они могут обращаться к полям конкретного объекта класса.\n\nЕсли тебе надо получить переменную из объекта то можно написать просто `this.*переменная*`. Ключевое слово `this` говорит об этом экземпляре. Вместо `this.*переменная*` внутри метода экземпляра класса прописанного в самом классе можно и просто юзнуть `*переменная*` и это будет одно и тоже, но, часто для ясности и исключения коллизий лучше будет заюзаь this. \nИспользование this может явно отделить экземплярный класс от статического\n```java\nclass Patient{ \n\tString name; \n\tint age; \n\tfloat height; \n\tpublic Patient(String name, int age, float height){ \n\t\tthis.name = name; \n\t\tthis.age = age; \n\t\tthis.height = height;\n\t} \n}\n```\n```java\nPatient patient1 = new Patient(\"Heinrich\", 40, 182.0f);\nPatient patient2 = new Patient(\"Mary\", 33, 171.5f);\n```","x":-1040,"y":-2705,"width":729,"height":691},
		{"id":"126bfd792e3ca0a7","type":"text","text":"# Getters and setters\nВ большинстве случаев класс не предоставляет доступ к своим полям другим классам. Вместо этого он делает свои поля доступными через так называемые [методы доступа](https://hyperskill.org/learn/step/3599 \"В Java метод доступа, также известный как геттер, — это метод, который позволяет считывать значение поля без нарушения инкапсуляции. | Используя методы доступа, программисты могут контролировать доступ к данным, изменять реализацию, не затрагивая другие части кода, и обеспечивать безопасность, скрывая детали реализации. Методы доступа предоставляют другим классам доступ к состоянию объекта, сохраняя при этом инкапсуляцию. Обычно они используются в сочетании с методами мутации, также известными как сеттеры, которые позволяют изменять значение поля.\"). Они обеспечивают [инкапсуляцию](https://hyperskill.org/learn/step/3599 \"В Java инкапсуляция — это практика объединения данных и методов, которые с ними работают, в единый модуль, обычно в класс. | Это позволяет повысить безопасность и контроль над данными, а также сделать структуру кода более организованной. Скрывая детали реализации класса от внешнего мира, инкапсуляция способствует модульному программированию и снижает риск повреждения данных. Кроме того, инкапсуляция может повысить читаемость и удобство сопровождения кода за счёт чёткого разделения задач. Как правило, класс не предоставляет доступ к своим полям другим классам. Вместо этого они становятся доступными через специальные методы, называемые методами доступа, также известными как геттеры и сеттеры. Эти методы обеспечивают инкапсуляцию, позволяя скрывать детали реализации и контролировать доступ к данным, обеспечивая безопасность. Согласно принципу инкапсуляции данных, к полям класса нельзя получить прямой доступ из других классов. Доступ к ним возможен только через методы этого конкретного класса. Для доступа к скрытым полям программисты пишут специальные методы, называемые геттерами и сеттерами.\"), которая позволяет скрывать детали реализации и контролировать доступ к данным, обеспечивая безопасность.\n- Согласно принципу **инкапсуляции данных**, доступ к полям класса из других классов невозможен. Доступ к полям возможен только через методы этого конкретного класса.\n\nЧтобы получить доступ к скрытым полям, программисты пишут специальные методы: **[геттеры](https://hyperskill.org/learn/step/3599 \"В Java геттеры — это методы, которые используются для получения и возврата значения поля в классе. | Они используются для защиты и сокрытия данных, обеспечивая контролируемый доступ к закрытым полям внутри класса. Геттеры важны для инкапсуляции данных, то есть для объединения данных и методов, которые ими управляют, в единую единицу, обычно в класс. Это позволяет повысить безопасность и контроль над данными, упорядочить структуру кода и снизить риск повреждения данных. Геттеры обычно содержат минимум программной логики и могут возвращать значения, которые не хранятся в памяти и вычисляются во время выполнения.\")** и **сеттеры**. Геттеры могут только считывать поля, а сеттеры — только записывать (изменять) поля. Оба типа методов должны быть `public`.\n# Добытчики и сеттеры\n\nВ Java нет специальных ключевых слов для методов получения и установки значений. Их главное отличие от других методов — в названии.\n\n- **геттеры** начинаются с **get**, за которым следует имя переменной, причём первая буква имени [переменной](https://hyperskill.org/learn/step/3599 \"В Java переменная — это именованное место хранения, которое используется для хранения значения определённого типа. | Она объявляется с указанием конкретного типа данных, который определяет тип значения, которое может в ней храниться. Каждая переменная имеет уникальное имя, также известное как идентификатор, которое используется для доступа к её значению. Переменные могут быть объявлены и инициализированы в одном операторе, а доступ к их значению и его изменение осуществляются с помощью имени. Важно отметить, что переменные можно изменять, то есть вы можете присвоить переменной новое значение без необходимости объявлять её заново.\") пишется заглавной;\n    \n- **сеттеры** начинаются с **set**, за которым следует имя переменной, причём первая буква имени переменной пишется заглавной.\n    \n\nЭто соглашение применимо к любому типу, кроме `boolean`.**Геттер** для логического поля начинается с **is**, за которым следует имя переменной.\n\n**Пример 1.** Класс `Account` имеет четыре поля: `id`, `code`, `balance` и `enabled`. Каждое поле имеет ключевое слово **private**, которое скрывает поле от прямого доступа из других классов. Кроме того, в классе есть **public** геттеры и сеттеры для доступа к полям через эти методы.\n```java\nclass Account {\n    private long id;\n    private String code;\n    private long balance;\n    private boolean enabled;\n    \n    public long getId() {\n        return id;\n    }\n    public void setId(long id) {\n        this.id = id;\n    }\n    public String getCode() {\n        return code;\n    }\n    public void setCode(String code) {\n        this.code = code;\n    }\n    public long getBalance() {\n        return balance;\n    }\n    public void setBalance(long balance) {\n        this.balance = balance;\n    }\n    public boolean isEnabled() {\n        return enabled;\n    }\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n}\n```\nЗдесь вы можете увидеть различные геттеры и сеттеры для класса `Account`. Как и указано в соглашении, логическое поле `enabled` имеет другое имя геттера: оно начинается со слова `is` вместо `get`.\n\nДавайте создадим экземпляр класса и заполним поля, а затем считаем значения из полей и выведем их.\n```java\nAccount account = new Account();\n\naccount.setId(1000);\naccount.setCode(\"62968503812\");\naccount.setBalance(100_000_000);\naccount.setEnabled(true);\n\nSystem.out.println(account.getId());      // 1000\nSystem.out.println(account.getCode());    // 62968503812\nSystem.out.println(account.getBalance()); // 100000000\nSystem.out.println(account.isEnabled());  // true\n```\nИногда **геттеры** или **сеттеры** могут содержать более сложную логику. Например, **геттеры** могут возвращать значения, которые не хранятся в памяти (вычисляются во время выполнения), а **сеттеры** в некоторых случаях могут изменять значение другого поля в соответствии с изменениями. Но обычно в геттерах и сеттерах используется минимум программистской логики.","x":-1896,"y":-1767,"width":856,"height":2020},
		{"id":"e2137dd20078879a","type":"file","file":"конспекты/java/photo_2019-08-09_16-54-47.svg","x":-200,"y":-2320,"width":884,"height":386},
		{"id":"7bf204c839ff41f9","type":"text","text":"# Модификаторы доступа\n#  **private**, **package-private**, **protected** и **public**\nКласс верхнего уровня может иметь один из двух следующих модификаторов:\n- **package-private (по умолчанию, без явного модификатора):** доступно только для классов из того же пакета;\n- **public:** доступно для всех классов везде.\n\nОбычно модификаторы классов верхнего уровня используются следующим образом:\n1. сделайте классы, содержащие методы для пользователей («кнопки»), **открытыми**;\n2. создайте все остальные классы с низкоуровневыми логическими методами, используемыми общедоступными классами **package-private** (накройте движок корпусом).\n\nПомните: всё, что не предназначено для использования/изменения классами из других пакетов, не должно быть общедоступным.\n\n- **private** — доступно только внутри класса;\n- **package-private** (также известный как **default**, неявный) — доступен для всех классов в одном пакете;\n- **protected** — доступно для классов в том же пакете и для подклассов;\n- **public** — доступно для всех классов везде.\n\nПомните, что при объявлении не вложенных классов можно использовать только модификаторы **public** или default (без ключевых слов). Все четыре модификатора можно применять к элементам класса: полям, методам и т. д.","x":-200,"y":-3136,"width":800,"height":740},
		{"id":"b9ba34c2e3ca6fdc","type":"file","file":"class_modifiers.svg","x":684,"y":-2986,"width":721,"height":281},
		{"id":"13e284144d8565f7","type":"text","text":"# В Java статический метод \n— это метод, связанный с классом, а не с экземпляром класса. | К нему можно получить прямой доступ, используя имя класса, и для этого не нужно создавать экземпляр класса. Статический метод может обращаться только к статическим полям и другим статическим методам в том же классе и не может ссылаться на ключевое слово `this`, поскольку у него нет контекста экземпляра. Статические методы часто используются как вспомогательные методы, предоставляющие общие функции для всего проекта. Их можно вызывать из методов экземпляра, но не наоборот.","x":-1620,"y":-2243,"width":547,"height":340},
		{"id":"9fc132b3ae8a7d6f","type":"text","text":"## Понимание: статический и инстанцированный\n- если есть слово `static`, то метод **статический**;\n- если слова `static` нет, то метод **экземплярный**.\n\nЧтобы вызвать [статический метод](\"\"), нам не нужно создавать объект. Мы просто вызываем метод, указав имя класса. Другими словами, можно сказать, что статический метод принадлежит классу (потому что нам не нужен объект)\n\nДля вызова [метода экземпляра](\"\") требуется другой способ. Как вы уже догадались, чтобы вызвать метод экземпляра, нужно сначала создать объект. В противном случае использовать метод экземпляра будет невозможно. Это называется методом экземпляра, потому что экземпляр — это конкретное представление объекта.","x":-1680,"y":-2705,"width":576,"height":410},
		{"id":"8d8ca2621a36bfe2","type":"file","file":"конспекты/java/Pasted image 20250727182928.png","x":2081,"y":-1700,"width":770,"height":526},
		{"id":"e60c4e1c581d0767","type":"text","text":"# Наследование\n```java\nclass SuperClass { }\nclass SubClassA extends SuperClass { }\nclass SubClassB extends SuperClass { }\nclass SubClassC extends SubClassA { }\n```\n- Java не поддерживает множественное наследование классов, то есть класс может наследоваться только от одного суперкласса.\n- Иерархия классов может иметь несколько уровней (класс `C` может наследоваться от класса `B`, который наследуется от класса `A`);\n- У суперкласса может быть несколько подклассов\n\nПодкласс наследует все открытые и защищённые поля и методы суперкласса. Подкласс также может добавлять новые поля и методы. Наследуемые и добавленные элементы будут использоваться одинаково.\n\nПодкласс не наследует [закрытые поля](https://hyperskill.org/learn/step/3583 \"In Java, a private field is a field that is declared with the access modifier 'private', which restricts access to that field to the class in which it is declared. | This means that other classes, even if they are in the same package, cannot directly access or modify the private field of the class. By using the private access modifier, you can encapsulate the implementation details of a class and provide a controlled interface for other classes to interact with it. Private fields are typically not exposed directly to other classes. Instead, they are made accessible through accessor methods, also known as getter and setter methods. These methods provide encapsulation, which allows you to hide implementation details and control data access, ensuring security. According to the data encapsulation principle, the field of a class should not be directly accessed from other classes. Instead, the field can be accessed only through the methods of that particular class. To access a hidden field, programmers write special types of methods called getters and setters. Getters can only read the field, and setters can only write to the field. For example, a class may have four fields, each of which is declared as private to hide the field from direct access from other classes. The class may also have public getters and setters for accessing the fields through these methods.\") и методы от суперкласса. Однако если у суперкласса есть открытые или защищённые методы для доступа к закрытым полям, эти элементы можно использовать в подклассах.\n\nКонструкторы не наследуются, но конструктор суперкласса можно вызвать из подкласса с помощью специального ключевого слова `super`.\n\nЕсли вы хотите, чтобы члены базового класса были доступны из всех подклассов, но не из внешнего кода (за исключением того же пакета), используйте модификатор доступа `protected`\n# Пример\n```java\nclass Person {\n    protected String name;\n    protected int yearOfBirth;\n    protected String address;\n    // public getters and setters for all fields here\n}\n\nclass Client extends Person {\n    protected String contractNumber;\n    protected boolean gold;\n    // public getters and setters for all fields here\n}\n\nclass Employee extends Person {\n    protected Date startDate;\n    protected Long salary;\n    // public getters and setters for all fields here\n}\n\nclass Programmer extends Employee {\n    protected String[] programmingLanguages;\n    public String[] getProgrammingLanguages() {\n        return programmingLanguages;\n    }\n    public void setProgrammingLanguages(String[] programmingLanguages) {\n        this.programmingLanguages = programmingLanguages;\n    }\n}\n\nclass Manager extends Employee {\n    protected boolean smile;\n    public boolean isSmile() {\n        return smile;\n    }\n    public void setSmile(boolean smile) {\n        this.smile = smile;\n    }\n}\n```\nЭта иерархия состоит из двух уровней и пяти классов. Все поля являются `protected` , то есть они видны подклассам. В каждом классе также есть общедоступные методы получения и установки значений, но некоторые из них не используются в коде, поскольку эти классы используют конструктор без аргументов по умолчанию.\n\nДавайте создадим объект класса `Programmer` и заполним унаследованные поля с помощью унаследованных сеттеров. Чтобы прочитать значения полей, мы можем использовать унаследованные геттеры.\n```java\nProgrammer p = new Programmer();\n\np.setName(\"John Elephant\");\np.setYearOfBirth(1985);\np.setAddress(\"Some street, 15\");\np.setStartDate(new Date());\np.setSalary(500_000L);\np.setProgrammingLanguages(new String[] { \"Java\", \"Scala\", \"Kotlin\" });\n\nSystem.out.println(p.getName()); // John Elephant\nSystem.out.println(p.getSalary()); // 500000\nSystem.out.println(Arrays.toString(p.getProgrammingLanguages())); // [Java, Scala, Kotlin]\n```\n\nЕсли класс объявлен с помощью ключевого слова `final`, у него вообще не может быть подклассов.\n```java\nfinal class SuperClass { }\n```\nЕсли вы попытаетесь расширить класс, возникнет ошибка компиляции.\n\nНекоторые стандартные классы объявлены как final: `Integer`, `Long`, `String`, `Math`. Их нельзя расширить.","x":-960,"y":-1767,"width":920,"height":2320}
	],
	"edges":[
		{"id":"70ed69a1a7691e91","fromNode":"13e284144d8565f7","fromSide":"top","toNode":"9fc132b3ae8a7d6f","toSide":"bottom"},
		{"id":"985a92c6dcc412bb","fromNode":"9fc132b3ae8a7d6f","fromSide":"bottom","toNode":"13e284144d8565f7","toSide":"top"},
		{"id":"79178e0c5b114df9","fromNode":"e0a45146fe80d6a3","fromSide":"left","toNode":"9fc132b3ae8a7d6f","toSide":"right"},
		{"id":"e191cd2b94c568e0","fromNode":"9fc132b3ae8a7d6f","fromSide":"right","toNode":"e0a45146fe80d6a3","toSide":"left"},
		{"id":"77440ca98a4bda7f","fromNode":"e2137dd20078879a","fromSide":"top","toNode":"7bf204c839ff41f9","toSide":"bottom"},
		{"id":"419fbf7f60872007","fromNode":"7bf204c839ff41f9","fromSide":"bottom","toNode":"e2137dd20078879a","toSide":"top"},
		{"id":"b1ea11266e72d7ec","fromNode":"b9ba34c2e3ca6fdc","fromSide":"left","toNode":"7bf204c839ff41f9","toSide":"right"},
		{"id":"d1f6956cf0ff39bb","fromNode":"b9ba34c2e3ca6fdc","fromSide":"left","toNode":"e2137dd20078879a","toSide":"right"},
		{"id":"abf3338b986188cb","fromNode":"e2137dd20078879a","fromSide":"right","toNode":"b9ba34c2e3ca6fdc","toSide":"left"},
		{"id":"218addc029fad0e3","fromNode":"7bf204c839ff41f9","fromSide":"right","toNode":"b9ba34c2e3ca6fdc","toSide":"left"},
		{"id":"e289bad38599d7f2","fromNode":"e60c4e1c581d0767","fromSide":"top","toNode":"126bfd792e3ca0a7","toSide":"top"},
		{"id":"6a2a18d28e88f73c","fromNode":"126bfd792e3ca0a7","fromSide":"top","toNode":"e60c4e1c581d0767","toSide":"top"}
	]
}